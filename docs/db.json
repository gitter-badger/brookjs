{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/documentation/source/css/docs.scss","path":"css/docs.scss","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1476496958000},{"_id":"source/component.md","hash":"97bf8ec2a7a21d7e0ed6c88eb0965fb233545681","modified":1476566103000},{"_id":"source/index.md","hash":"b10a3b1d52ba97ee87331abed908484cba94f85f","modified":1476565367000},{"_id":"themes/documentation/.DS_Store","hash":"26bebb3de305561c6d70b91b9c4c399078233489","modified":1476498774000},{"_id":"themes/documentation/_config.yml","hash":"670d6f859f7f380466281ae4ca7028ad29469a72","modified":1476566616000},{"_id":"source/_data/nav.yml","hash":"7b1755b6cb2adb1cbaeacfc6029ac6e082dcdce9","modified":1476565916000},{"_id":"themes/documentation/helper/index.js","hash":"b4dcdb4ee4f29b0201d890198dbf9416dc6c0150","modified":1476563622000},{"_id":"themes/documentation/layout/index.hbs","hash":"8744b89b9a8216417f4180262ccdb3b622e7c8f1","modified":1476566258000},{"_id":"themes/documentation/source/css/_code.scss","hash":"fe353077bc2bfff386459ee8065202201bb5ec0d","modified":1476564145000},{"_id":"themes/documentation/source/css/_content.scss","hash":"0fbb951dfb7942f6e5bf2536782894864d610d9e","modified":1463522094000},{"_id":"themes/documentation/source/css/_menu.scss","hash":"a72ba17db23e59dc980e831df2246c015605e92a","modified":1463522094000},{"_id":"themes/documentation/source/css/_typography.scss","hash":"06ac832e3ae656ea47b818e7dc6524fcad71b241","modified":1463522094000},{"_id":"themes/documentation/source/css/docs.scss","hash":"c4185a629de88bd667ce25adaea31b5b1dca19c9","modified":1463522094000}],"Category":[],"Data":[{"_id":"nav","data":[{"title":"Introduction","items":[{"id":"index","title":"Meet brookjs"}]},{"title":"Modules","items":[{"id":"component","title":"component"}]}]}],"Page":[{"id":"component","title":"<code>component</code>","_content":"\n`brookjs/component` creates factory functions of `Kefir.Observable`s to manage the lifecycle of a piece of an application's UI. They are designed to mount an already rendered DOM, with the server providing the DOM and a `Kefir.Observable` of component props.\n\n`brookjs/component` factories can be composed of subcomponent, event, and render `Kefir.Observable` returning functions, as well as a `combinator` function, and returns a combined `Kefir.Observable` of values emitted from this combination. Each of these configuration options are optional. A component that doesn't do anything may not be particularly useful, but it is possible. \n\n# How to Use\n\n`brookjs/component` is a factory function for defining your custom component. \n\n```js\nimport { component } from 'brookjs';\nimport Kefir from 'kefir';\n\nconst events = el => Kefir.fromEvents(el, 'click')\n    .map(() => ({ type: 'COMPONENT_CLICK' }));\n\nconst render = (el, props, update) => Kefir.stream(emitter => {\n   let loop = requestAnimationFrame(() => {\n       if (state.disabled !== update.disabled) {\n           el.disabled = update.disabled;\n       }\n\n       emitter.end();\n   });\n   \n   return () => cancelAnimationFrame(loop);\n});\n\nconst subcomponents = () => Kefir.never(); // coming soon!\n\nexport default component({ events, render, subcomponents });\n```\n\nSomewhere else, mount the component to its element and subscribe to its actions:\n\n```js\nimport DummyComponent from './dummy';\n\nconst { __INITIAL_STATE__ } = global;\n\nconst app = DummyComponent(el.getElementById('app'), __INITIAL_STATE__);\n\nlet sub = app.observe({ value: action => console.log(action)});\n```\n\nIt is recommended to break each configuration function out into a separate module, which you then import into the main component definition. This way, each individual stream factory can be tested in isolation without needing to test the framework.\n\nEach of these configuration options have an associated module, which exports a factory function for generating each of these functions from another set of configuration options.\n\n* [brookjs/render](../render/README.md)\n* [brookjs/events](../events/README.md)\n\n*Note: A factory function for `subcomponents` is currently on the roadmap for v0.1.0. The API is still being defined.*\n\n## Configuration Object\n\nThe configuration object allows you to define the behavior of your component at various points in its lifecycle. All stream generating functions provide ways of emitting values into the component stream. All of the properties of the configuration object are optional.\n\n**All functions must be curried.** `brookjs` relies on ramda for functional programming helpers, and highly recommend using the same. The `commonjs` build will use `babel-plugin-ramda` to ensure the build is no larger than it needs to be.\n\n* `{Function}` events - `events$` stream returning function. Called whenever the previous `render$` stream ends, passing the component element `el` and allowing the component to rebind the events to the new DOM. The previous `events$` stream get unsubscribed, so ensure all cleanup code is declared correctly.\n    * Parameters:\n        * `{Element}` el - Component element to bind events to.\n    * Returns:\n        * `Kefir.Observable<FluxStandardAction>` - Observable emitting Flux Standard Action values.\n* `{Object[]}` subcomponents - Configuration for each subcomponent.\n    * *Note: `subcomponents` is not finalized and subject to change before v0.1.0.*\n    * `{Function}` factory - Child's Component factory function. Should generate a component instance.\n    * `{Function}` adapter *(optional)* - Called with state before instance creation & render. Called with the current state. Should return the state to be passed into the given component.\n    * `{string}` selector *(optional)* - Child's query string. Used to query the child's element. If not provided, will use the provided element.\n    * `{Function}` preplug *(optional)* - Called with the child instance before being plugged into stream. Provides a hook to modify the stream before it's plugged into the Downstreams stream.\n* `{Function}` render - `render$` stream returning function. Called whenever the props change, passing the component element `el`, the previous `props`, and `next` props.\n    * Parameters:\n        * `{Element}` el - Component element.\n        * `{Object}` props - Previous component props.\n        * `{Object}` next - Next component props.\n    * Returns:\n        * `Kefir.Observable<FluxStandardAction>` - Observable emitting Flux Standard. Should ends when the element is updated, allowing the events to be rebound. Can aslo simply emit the component's actions, providing an extension point for React/virtual-dom based rendering streams.\n\n            When the next `render$` stream is generated, the previous stream is unsubscribed, so ensure all cleanup code is declared correctly.`This is a great place to cut the previous animation short when the next props tell the component to animate differently.\n\n**Note: At this time, consider anything undocumented to be unstable until `v0.1.0`.** \n\n  [fsa]: https://github.com/acdlite/flux-standard-action\n","source":"component.md","raw":"---\nid: component\ntitle: <code>component</code>\n---\n\n`brookjs/component` creates factory functions of `Kefir.Observable`s to manage the lifecycle of a piece of an application's UI. They are designed to mount an already rendered DOM, with the server providing the DOM and a `Kefir.Observable` of component props.\n\n`brookjs/component` factories can be composed of subcomponent, event, and render `Kefir.Observable` returning functions, as well as a `combinator` function, and returns a combined `Kefir.Observable` of values emitted from this combination. Each of these configuration options are optional. A component that doesn't do anything may not be particularly useful, but it is possible. \n\n# How to Use\n\n`brookjs/component` is a factory function for defining your custom component. \n\n```js\nimport { component } from 'brookjs';\nimport Kefir from 'kefir';\n\nconst events = el => Kefir.fromEvents(el, 'click')\n    .map(() => ({ type: 'COMPONENT_CLICK' }));\n\nconst render = (el, props, update) => Kefir.stream(emitter => {\n   let loop = requestAnimationFrame(() => {\n       if (state.disabled !== update.disabled) {\n           el.disabled = update.disabled;\n       }\n\n       emitter.end();\n   });\n   \n   return () => cancelAnimationFrame(loop);\n});\n\nconst subcomponents = () => Kefir.never(); // coming soon!\n\nexport default component({ events, render, subcomponents });\n```\n\nSomewhere else, mount the component to its element and subscribe to its actions:\n\n```js\nimport DummyComponent from './dummy';\n\nconst { __INITIAL_STATE__ } = global;\n\nconst app = DummyComponent(el.getElementById('app'), __INITIAL_STATE__);\n\nlet sub = app.observe({ value: action => console.log(action)});\n```\n\nIt is recommended to break each configuration function out into a separate module, which you then import into the main component definition. This way, each individual stream factory can be tested in isolation without needing to test the framework.\n\nEach of these configuration options have an associated module, which exports a factory function for generating each of these functions from another set of configuration options.\n\n* [brookjs/render](../render/README.md)\n* [brookjs/events](../events/README.md)\n\n*Note: A factory function for `subcomponents` is currently on the roadmap for v0.1.0. The API is still being defined.*\n\n## Configuration Object\n\nThe configuration object allows you to define the behavior of your component at various points in its lifecycle. All stream generating functions provide ways of emitting values into the component stream. All of the properties of the configuration object are optional.\n\n**All functions must be curried.** `brookjs` relies on ramda for functional programming helpers, and highly recommend using the same. The `commonjs` build will use `babel-plugin-ramda` to ensure the build is no larger than it needs to be.\n\n* `{Function}` events - `events$` stream returning function. Called whenever the previous `render$` stream ends, passing the component element `el` and allowing the component to rebind the events to the new DOM. The previous `events$` stream get unsubscribed, so ensure all cleanup code is declared correctly.\n    * Parameters:\n        * `{Element}` el - Component element to bind events to.\n    * Returns:\n        * `Kefir.Observable<FluxStandardAction>` - Observable emitting Flux Standard Action values.\n* `{Object[]}` subcomponents - Configuration for each subcomponent.\n    * *Note: `subcomponents` is not finalized and subject to change before v0.1.0.*\n    * `{Function}` factory - Child's Component factory function. Should generate a component instance.\n    * `{Function}` adapter *(optional)* - Called with state before instance creation & render. Called with the current state. Should return the state to be passed into the given component.\n    * `{string}` selector *(optional)* - Child's query string. Used to query the child's element. If not provided, will use the provided element.\n    * `{Function}` preplug *(optional)* - Called with the child instance before being plugged into stream. Provides a hook to modify the stream before it's plugged into the Downstreams stream.\n* `{Function}` render - `render$` stream returning function. Called whenever the props change, passing the component element `el`, the previous `props`, and `next` props.\n    * Parameters:\n        * `{Element}` el - Component element.\n        * `{Object}` props - Previous component props.\n        * `{Object}` next - Next component props.\n    * Returns:\n        * `Kefir.Observable<FluxStandardAction>` - Observable emitting Flux Standard. Should ends when the element is updated, allowing the events to be rebound. Can aslo simply emit the component's actions, providing an extension point for React/virtual-dom based rendering streams.\n\n            When the next `render$` stream is generated, the previous stream is unsubscribed, so ensure all cleanup code is declared correctly.`This is a great place to cut the previous animation short when the next props tell the component to animate differently.\n\n**Note: At this time, consider anything undocumented to be unstable until `v0.1.0`.** \n\n  [fsa]: https://github.com/acdlite/flux-standard-action\n","date":"2016-10-15T21:15:03.000Z","updated":"2016-10-15T21:15:03.000Z","path":"component.html","comments":1,"layout":"page","_id":"ciubq0uo80000iurzr77t26a2","content":"<p><code>brookjs/component</code> creates factory functions of <code>Kefir.Observable</code>s to manage the lifecycle of a piece of an application’s UI. They are designed to mount an already rendered DOM, with the server providing the DOM and a <code>Kefir.Observable</code> of component props.</p>\n<p><code>brookjs/component</code> factories can be composed of subcomponent, event, and render <code>Kefir.Observable</code> returning functions, as well as a <code>combinator</code> function, and returns a combined <code>Kefir.Observable</code> of values emitted from this combination. Each of these configuration options are optional. A component that doesn’t do anything may not be particularly useful, but it is possible. </p>\n<h1 id=\"How-to-Use\"><a href=\"#How-to-Use\" class=\"headerlink\" title=\"How to Use\"></a>How to Use</h1><p><code>brookjs/component</code> is a factory function for defining your custom component. </p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\" >import</span> <span class=\"token punctuation\" >{</span> component <span class=\"token punctuation\" >}</span> <span class=\"token keyword\" >from</span> <span class=\"token string\" >'brookjs'</span><span class=\"token punctuation\" >;</span>\n<span class=\"token keyword\" >import</span> Kefir <span class=\"token keyword\" >from</span> <span class=\"token string\" >'kefir'</span><span class=\"token punctuation\" >;</span>\n\n<span class=\"token keyword\" >const</span> events <span class=\"token operator\" >=</span> el <span class=\"token operator\" >=</span><span class=\"token operator\" >></span> Kefir<span class=\"token punctuation\" >.</span><span class=\"token function\" >fromEvents</span><span class=\"token punctuation\" >(</span>el<span class=\"token punctuation\" >,</span> <span class=\"token string\" >'click'</span><span class=\"token punctuation\" >)</span>\n    <span class=\"token punctuation\" >.</span><span class=\"token function\" >map</span><span class=\"token punctuation\" >(</span><span class=\"token punctuation\" >(</span><span class=\"token punctuation\" >)</span> <span class=\"token operator\" >=</span><span class=\"token operator\" >></span> <span class=\"token punctuation\" >(</span><span class=\"token punctuation\" >{</span> type<span class=\"token punctuation\" >:</span> <span class=\"token string\" >'COMPONENT_CLICK'</span> <span class=\"token punctuation\" >}</span><span class=\"token punctuation\" >)</span><span class=\"token punctuation\" >)</span><span class=\"token punctuation\" >;</span>\n\n<span class=\"token keyword\" >const</span> render <span class=\"token operator\" >=</span> <span class=\"token punctuation\" >(</span>el<span class=\"token punctuation\" >,</span> props<span class=\"token punctuation\" >,</span> update<span class=\"token punctuation\" >)</span> <span class=\"token operator\" >=</span><span class=\"token operator\" >></span> Kefir<span class=\"token punctuation\" >.</span><span class=\"token function\" >stream</span><span class=\"token punctuation\" >(</span>emitter <span class=\"token operator\" >=</span><span class=\"token operator\" >></span> <span class=\"token punctuation\" >{</span>\n   <span class=\"token keyword\" >let</span> loop <span class=\"token operator\" >=</span> <span class=\"token function\" >requestAnimationFrame</span><span class=\"token punctuation\" >(</span><span class=\"token punctuation\" >(</span><span class=\"token punctuation\" >)</span> <span class=\"token operator\" >=</span><span class=\"token operator\" >></span> <span class=\"token punctuation\" >{</span>\n       <span class=\"token keyword\" >if</span> <span class=\"token punctuation\" >(</span>state<span class=\"token punctuation\" >.</span>disabled <span class=\"token operator\" >!==</span> update<span class=\"token punctuation\" >.</span>disabled<span class=\"token punctuation\" >)</span> <span class=\"token punctuation\" >{</span>\n           el<span class=\"token punctuation\" >.</span>disabled <span class=\"token operator\" >=</span> update<span class=\"token punctuation\" >.</span>disabled<span class=\"token punctuation\" >;</span>\n       <span class=\"token punctuation\" >}</span>\n\n       emitter<span class=\"token punctuation\" >.</span><span class=\"token function\" >end</span><span class=\"token punctuation\" >(</span><span class=\"token punctuation\" >)</span><span class=\"token punctuation\" >;</span>\n   <span class=\"token punctuation\" >}</span><span class=\"token punctuation\" >)</span><span class=\"token punctuation\" >;</span>\n\n   <span class=\"token keyword\" >return</span> <span class=\"token punctuation\" >(</span><span class=\"token punctuation\" >)</span> <span class=\"token operator\" >=</span><span class=\"token operator\" >></span> <span class=\"token function\" >cancelAnimationFrame</span><span class=\"token punctuation\" >(</span>loop<span class=\"token punctuation\" >)</span><span class=\"token punctuation\" >;</span>\n<span class=\"token punctuation\" >}</span><span class=\"token punctuation\" >)</span><span class=\"token punctuation\" >;</span>\n\n<span class=\"token keyword\" >const</span> subcomponents <span class=\"token operator\" >=</span> <span class=\"token punctuation\" >(</span><span class=\"token punctuation\" >)</span> <span class=\"token operator\" >=</span><span class=\"token operator\" >></span> Kefir<span class=\"token punctuation\" >.</span><span class=\"token function\" >never</span><span class=\"token punctuation\" >(</span><span class=\"token punctuation\" >)</span><span class=\"token punctuation\" >;</span> <span class=\"token comment\" spellcheck=\"true\">// coming soon!</span>\n\n<span class=\"token keyword\" >export</span> <span class=\"token keyword\" >default</span> <span class=\"token function\" >component</span><span class=\"token punctuation\" >(</span><span class=\"token punctuation\" >{</span> events<span class=\"token punctuation\" >,</span> render<span class=\"token punctuation\" >,</span> subcomponents <span class=\"token punctuation\" >}</span><span class=\"token punctuation\" >)</span><span class=\"token punctuation\" >;</span>\n</code></pre>\n<p>Somewhere else, mount the component to its element and subscribe to its actions:</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\" >import</span> DummyComponent <span class=\"token keyword\" >from</span> <span class=\"token string\" >'./dummy'</span><span class=\"token punctuation\" >;</span>\n\n<span class=\"token keyword\" >const</span> <span class=\"token punctuation\" >{</span> __INITIAL_STATE__ <span class=\"token punctuation\" >}</span> <span class=\"token operator\" >=</span> global<span class=\"token punctuation\" >;</span>\n\n<span class=\"token keyword\" >const</span> app <span class=\"token operator\" >=</span> <span class=\"token function\" >DummyComponent</span><span class=\"token punctuation\" >(</span>el<span class=\"token punctuation\" >.</span><span class=\"token function\" >getElementById</span><span class=\"token punctuation\" >(</span><span class=\"token string\" >'app'</span><span class=\"token punctuation\" >)</span><span class=\"token punctuation\" >,</span> __INITIAL_STATE__<span class=\"token punctuation\" >)</span><span class=\"token punctuation\" >;</span>\n\n<span class=\"token keyword\" >let</span> sub <span class=\"token operator\" >=</span> app<span class=\"token punctuation\" >.</span><span class=\"token function\" >observe</span><span class=\"token punctuation\" >(</span><span class=\"token punctuation\" >{</span> value<span class=\"token punctuation\" >:</span> action <span class=\"token operator\" >=</span><span class=\"token operator\" >></span> console<span class=\"token punctuation\" >.</span><span class=\"token function\" >log</span><span class=\"token punctuation\" >(</span>action<span class=\"token punctuation\" >)</span><span class=\"token punctuation\" >}</span><span class=\"token punctuation\" >)</span><span class=\"token punctuation\" >;</span>\n</code></pre>\n<p>It is recommended to break each configuration function out into a separate module, which you then import into the main component definition. This way, each individual stream factory can be tested in isolation without needing to test the framework.</p>\n<p>Each of these configuration options have an associated module, which exports a factory function for generating each of these functions from another set of configuration options.</p>\n<ul>\n<li><a href=\"../render/README.md\">brookjs/render</a></li>\n<li><a href=\"../events/README.md\">brookjs/events</a></li>\n</ul>\n<p><em>Note: A factory function for <code>subcomponents</code> is currently on the roadmap for v0.1.0. The API is still being defined.</em></p>\n<h2 id=\"Configuration-Object\"><a href=\"#Configuration-Object\" class=\"headerlink\" title=\"Configuration Object\"></a>Configuration Object</h2><p>The configuration object allows you to define the behavior of your component at various points in its lifecycle. All stream generating functions provide ways of emitting values into the component stream. All of the properties of the configuration object are optional.</p>\n<p><strong>All functions must be curried.</strong> <code>brookjs</code> relies on ramda for functional programming helpers, and highly recommend using the same. The <code>commonjs</code> build will use <code>babel-plugin-ramda</code> to ensure the build is no larger than it needs to be.</p>\n<ul>\n<li><code>{Function}</code> events - <code>events$</code> stream returning function. Called whenever the previous <code>render$</code> stream ends, passing the component element <code>el</code> and allowing the component to rebind the events to the new DOM. The previous <code>events$</code> stream get unsubscribed, so ensure all cleanup code is declared correctly.<ul>\n<li>Parameters:<ul>\n<li><code>{Element}</code> el - Component element to bind events to.</li>\n</ul>\n</li>\n<li>Returns:<ul>\n<li><code>Kefir.Observable&lt;FluxStandardAction&gt;</code> - Observable emitting Flux Standard Action values.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>{Object[]}</code> subcomponents - Configuration for each subcomponent.<ul>\n<li><em>Note: <code>subcomponents</code> is not finalized and subject to change before v0.1.0.</em></li>\n<li><code>{Function}</code> factory - Child’s Component factory function. Should generate a component instance.</li>\n<li><code>{Function}</code> adapter <em>(optional)</em> - Called with state before instance creation &amp; render. Called with the current state. Should return the state to be passed into the given component.</li>\n<li><code>{string}</code> selector <em>(optional)</em> - Child’s query string. Used to query the child’s element. If not provided, will use the provided element.</li>\n<li><code>{Function}</code> preplug <em>(optional)</em> - Called with the child instance before being plugged into stream. Provides a hook to modify the stream before it’s plugged into the Downstreams stream.</li>\n</ul>\n</li>\n<li><p><code>{Function}</code> render - <code>render$</code> stream returning function. Called whenever the props change, passing the component element <code>el</code>, the previous <code>props</code>, and <code>next</code> props.</p>\n<ul>\n<li>Parameters:<ul>\n<li><code>{Element}</code> el - Component element.</li>\n<li><code>{Object}</code> props - Previous component props.</li>\n<li><code>{Object}</code> next - Next component props.</li>\n</ul>\n</li>\n<li><p>Returns:</p>\n<ul>\n<li><p><code>Kefir.Observable&lt;FluxStandardAction&gt;</code> - Observable emitting Flux Standard. Should ends when the element is updated, allowing the events to be rebound. Can aslo simply emit the component’s actions, providing an extension point for React/virtual-dom based rendering streams.</p>\n<p>  When the next <code>render$</code> stream is generated, the previous stream is unsubscribed, so ensure all cleanup code is declared correctly.`This is a great place to cut the previous animation short when the next props tell the component to animate differently.</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Note: At this time, consider anything undocumented to be unstable until <code>v0.1.0</code>.</strong> </p>\n<link href=\"/brookjs/css/prism-solarizedlight.css\" rel=\"stylesheet\">","excerpt":"","more":"<p><code>brookjs/component</code> creates factory functions of <code>Kefir.Observable</code>s to manage the lifecycle of a piece of an application’s UI. They are designed to mount an already rendered DOM, with the server providing the DOM and a <code>Kefir.Observable</code> of component props.</p>\n<p><code>brookjs/component</code> factories can be composed of subcomponent, event, and render <code>Kefir.Observable</code> returning functions, as well as a <code>combinator</code> function, and returns a combined <code>Kefir.Observable</code> of values emitted from this combination. Each of these configuration options are optional. A component that doesn’t do anything may not be particularly useful, but it is possible. </p>\n<h1 id=\"How-to-Use\"><a href=\"#How-to-Use\" class=\"headerlink\" title=\"How to Use\"></a>How to Use</h1><p><code>brookjs/component</code> is a factory function for defining your custom component. </p>\n<pre><code class=\"js\">import { component } from &#39;brookjs&#39;;\nimport Kefir from &#39;kefir&#39;;\n\nconst events = el =&gt; Kefir.fromEvents(el, &#39;click&#39;)\n    .map(() =&gt; ({ type: &#39;COMPONENT_CLICK&#39; }));\n\nconst render = (el, props, update) =&gt; Kefir.stream(emitter =&gt; {\n   let loop = requestAnimationFrame(() =&gt; {\n       if (state.disabled !== update.disabled) {\n           el.disabled = update.disabled;\n       }\n\n       emitter.end();\n   });\n\n   return () =&gt; cancelAnimationFrame(loop);\n});\n\nconst subcomponents = () =&gt; Kefir.never(); // coming soon!\n\nexport default component({ events, render, subcomponents });\n</code></pre>\n<p>Somewhere else, mount the component to its element and subscribe to its actions:</p>\n<pre><code class=\"js\">import DummyComponent from &#39;./dummy&#39;;\n\nconst { __INITIAL_STATE__ } = global;\n\nconst app = DummyComponent(el.getElementById(&#39;app&#39;), __INITIAL_STATE__);\n\nlet sub = app.observe({ value: action =&gt; console.log(action)});\n</code></pre>\n<p>It is recommended to break each configuration function out into a separate module, which you then import into the main component definition. This way, each individual stream factory can be tested in isolation without needing to test the framework.</p>\n<p>Each of these configuration options have an associated module, which exports a factory function for generating each of these functions from another set of configuration options.</p>\n<ul>\n<li><a href=\"../render/README.md\">brookjs/render</a></li>\n<li><a href=\"../events/README.md\">brookjs/events</a></li>\n</ul>\n<p><em>Note: A factory function for <code>subcomponents</code> is currently on the roadmap for v0.1.0. The API is still being defined.</em></p>\n<h2 id=\"Configuration-Object\"><a href=\"#Configuration-Object\" class=\"headerlink\" title=\"Configuration Object\"></a>Configuration Object</h2><p>The configuration object allows you to define the behavior of your component at various points in its lifecycle. All stream generating functions provide ways of emitting values into the component stream. All of the properties of the configuration object are optional.</p>\n<p><strong>All functions must be curried.</strong> <code>brookjs</code> relies on ramda for functional programming helpers, and highly recommend using the same. The <code>commonjs</code> build will use <code>babel-plugin-ramda</code> to ensure the build is no larger than it needs to be.</p>\n<ul>\n<li><code>{Function}</code> events - <code>events$</code> stream returning function. Called whenever the previous <code>render$</code> stream ends, passing the component element <code>el</code> and allowing the component to rebind the events to the new DOM. The previous <code>events$</code> stream get unsubscribed, so ensure all cleanup code is declared correctly.<ul>\n<li>Parameters:<ul>\n<li><code>{Element}</code> el - Component element to bind events to.</li>\n</ul>\n</li>\n<li>Returns:<ul>\n<li><code>Kefir.Observable&lt;FluxStandardAction&gt;</code> - Observable emitting Flux Standard Action values.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>{Object[]}</code> subcomponents - Configuration for each subcomponent.<ul>\n<li><em>Note: <code>subcomponents</code> is not finalized and subject to change before v0.1.0.</em></li>\n<li><code>{Function}</code> factory - Child’s Component factory function. Should generate a component instance.</li>\n<li><code>{Function}</code> adapter <em>(optional)</em> - Called with state before instance creation &amp; render. Called with the current state. Should return the state to be passed into the given component.</li>\n<li><code>{string}</code> selector <em>(optional)</em> - Child’s query string. Used to query the child’s element. If not provided, will use the provided element.</li>\n<li><code>{Function}</code> preplug <em>(optional)</em> - Called with the child instance before being plugged into stream. Provides a hook to modify the stream before it’s plugged into the Downstreams stream.</li>\n</ul>\n</li>\n<li><p><code>{Function}</code> render - <code>render$</code> stream returning function. Called whenever the props change, passing the component element <code>el</code>, the previous <code>props</code>, and <code>next</code> props.</p>\n<ul>\n<li>Parameters:<ul>\n<li><code>{Element}</code> el - Component element.</li>\n<li><code>{Object}</code> props - Previous component props.</li>\n<li><code>{Object}</code> next - Next component props.</li>\n</ul>\n</li>\n<li><p>Returns:</p>\n<ul>\n<li><p><code>Kefir.Observable&lt;FluxStandardAction&gt;</code> - Observable emitting Flux Standard. Should ends when the element is updated, allowing the events to be rebound. Can aslo simply emit the component’s actions, providing an extension point for React/virtual-dom based rendering streams.</p>\n<p>  When the next <code>render$</code> stream is generated, the previous stream is unsubscribed, so ensure all cleanup code is declared correctly.`This is a great place to cut the previous animation short when the next props tell the component to animate differently.</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Note: At this time, consider anything undocumented to be unstable until <code>v0.1.0</code>.</strong> </p>\n"},{"id":"index","title":"Meet brookjs","_content":"\n`brookjs` is framework for building functional, reactive JavaScript applications. The core of the library is built on [`kefir`][kefir] for Observables and [`ramda`][ramda] for functional utilities. No other dependencies are required, and the framework is designed to be as flexible as possible, allowing you to pick and choose which modules to use while designing them to work together seamlessly in common patterns. While not required, [`redux`][redux] is recommended for state management, with its `Symbol.observable` interop, solid developer tooling, and supportive community.\n\n`brookjs` modules handle various aspects of an application, with the core of the library being the `component` module, handling the DOM lifecycle, and the `observeDelta` middleware, which provides an Observable-based managing side effects. Additional modules provide support for other application functionality.\n\n  [kefir]: http://rpominov.github.io/kefir/\n  [ramda]: http://ramdajs.com/\n  [redux]: http://redux.js.org/\n","source":"index.md","raw":"---\nid: index\ntitle: Meet brookjs\n---\n\n`brookjs` is framework for building functional, reactive JavaScript applications. The core of the library is built on [`kefir`][kefir] for Observables and [`ramda`][ramda] for functional utilities. No other dependencies are required, and the framework is designed to be as flexible as possible, allowing you to pick and choose which modules to use while designing them to work together seamlessly in common patterns. While not required, [`redux`][redux] is recommended for state management, with its `Symbol.observable` interop, solid developer tooling, and supportive community.\n\n`brookjs` modules handle various aspects of an application, with the core of the library being the `component` module, handling the DOM lifecycle, and the `observeDelta` middleware, which provides an Observable-based managing side effects. Additional modules provide support for other application functionality.\n\n  [kefir]: http://rpominov.github.io/kefir/\n  [ramda]: http://ramdajs.com/\n  [redux]: http://redux.js.org/\n","date":"2016-10-15T21:02:47.000Z","updated":"2016-10-15T21:02:47.000Z","path":"index.html","comments":1,"layout":"page","_id":"ciubq0uob0001iurzv01ob19x","content":"<p><code>brookjs</code> is framework for building functional, reactive JavaScript applications. The core of the library is built on <a href=\"http://rpominov.github.io/kefir/\" target=\"_blank\" rel=\"external\"><code>kefir</code></a> for Observables and <a href=\"http://ramdajs.com/\" target=\"_blank\" rel=\"external\"><code>ramda</code></a> for functional utilities. No other dependencies are required, and the framework is designed to be as flexible as possible, allowing you to pick and choose which modules to use while designing them to work together seamlessly in common patterns. While not required, <a href=\"http://redux.js.org/\" target=\"_blank\" rel=\"external\"><code>redux</code></a> is recommended for state management, with its <code>Symbol.observable</code> interop, solid developer tooling, and supportive community.</p>\n<p><code>brookjs</code> modules handle various aspects of an application, with the core of the library being the <code>component</code> module, handling the DOM lifecycle, and the <code>observeDelta</code> middleware, which provides an Observable-based managing side effects. Additional modules provide support for other application functionality.</p>\n<link href=\"/brookjs/css/prism-solarizedlight.css\" rel=\"stylesheet\">","excerpt":"","more":"<p><code>brookjs</code> is framework for building functional, reactive JavaScript applications. The core of the library is built on <a href=\"http://rpominov.github.io/kefir/\"><code>kefir</code></a> for Observables and <a href=\"http://ramdajs.com/\"><code>ramda</code></a> for functional utilities. No other dependencies are required, and the framework is designed to be as flexible as possible, allowing you to pick and choose which modules to use while designing them to work together seamlessly in common patterns. While not required, <a href=\"http://redux.js.org/\"><code>redux</code></a> is recommended for state management, with its <code>Symbol.observable</code> interop, solid developer tooling, and supportive community.</p>\n<p><code>brookjs</code> modules handle various aspects of an application, with the core of the library being the <code>component</code> module, handling the DOM lifecycle, and the <code>observeDelta</code> middleware, which provides an Observable-based managing side effects. Additional modules provide support for other application functionality.</p>\n"}],"Post":[],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}